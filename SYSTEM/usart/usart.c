#include "sys.h"
#include "usart.h"	
#include "oled.h"
////////////////////////////////////////////////////////////////////////////////// 	 
//如果使用ucos,则包括下面的头文件即可.
#if SYSTEM_SUPPORT_OS
#include "includes.h"					//ucos 使用	  
#endif

//加入以下代码,支持printf函数,而不需要选择use MicroLIB	  
#if 1
#pragma import(__use_no_semihosting)  
//解决HAL库使用时,某些情况可能报错的bug
int _ttywrch(int ch)    
{
    ch=ch;
	return ch;
}
//标准库需要的支持函数                 
struct __FILE 
{ 
	int handle; 
	/* Whatever you require here. If the only file you are using is */ 
	/* standard output using printf() for debugging, no file handling */ 
	/* is required. */ 
}; 
/* FILE is typedef’ d in stdio.h. */ 
FILE __stdout;       
//定义_sys_exit()以避免使用半主机模式    
void _sys_exit(int x) 
{ 
	x = x; 
} 
//重定义fputc函数 
/*int fputc(int ch, FILE *f)
{      
	while((USART1->SR&0X40)==0);//循环发送,直到发送完毕   
	USART1->DR = (u8) ch;      
	return ch;
}*/
#endif 
//end
//////////////////////////////////////////////////////////////////

#if EN_USART1_RX   //如果使能了接收
//串口1中断服务程序
//注意,读取USARTx->SR能避免莫名其妙的错误   	
u8 USART_RX_BUF[USART_REC_LEN];     //接收缓冲,最大USART_REC_LEN个字节.
u8 USART6_RX_BUF[USART6_REC_LEN];

//接收状态
//bit15，	接收完成标志
//bit14，	接收到0x0d
//bit13~0，	接收到的有效字节数目
u16 USART_RX_STA=0;       //接收状态标记
u16 USART6_RX_STA=0;       //接收状态标记	


  
void USART1_IRQHandler(void)
{
u8 Data=0;
    if (USART_GetFlagStatus(USART1, USART_FLAG_PE) != RESET)
   {
       USART_ReceiveData(USART1);
     USART_ClearFlag(USART1, USART_FLAG_PE);
   }
   if (USART_GetFlagStatus(USART1, USART_FLAG_ORE) != RESET)
   {
       USART_ReceiveData(USART1);
     USART_ClearFlag(USART1, USART_FLAG_ORE);
   }
    
    if (USART_GetFlagStatus(USART1, USART_FLAG_FE) != RESET)
   {
       USART_ReceiveData(USART1);
      USART_ClearFlag(USART1, USART_FLAG_FE);
   }
//为了避免接收错误,将一些不正常状态滤掉
    if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)
    {   
        USART_ClearFlag(USART1, USART_FLAG_RXNE);
        USART_ClearITPendingBit(USART1, USART_IT_RXNE);
        Data = USART_ReceiveData(USART1);
		OPENMV_date_anl(Data); //处理函数
    } 
//	u8 res;	
//#if SYSTEM_SUPPORT_OS 		//如果SYSTEM_SUPPORT_OS为真，则需要支持OS.
//	OSIntEnter();    
//#endif
//	if(USART1->SR&(1<<5))//接收到数据
//	{	 
//		res=USART1->DR; 
//		if((USART_RX_STA&0x8000)==0)//接收未完成
//		{
//			if(USART_RX_STA&0x4000)//接收到了0x0d
//			{
//				if(res!=0x0a)USART_RX_STA=0;//接收错误,重新开始
//				else USART_RX_STA|=0x8000;	//接收完成了 
//			}else //还没收到0X0D
//			{	
//				if(res==0x0d)USART_RX_STA|=0x4000;
//				else
//				{
//					USART_RX_BUF[USART_RX_STA&0X3FFF]=res;
//					USART_RX_STA++;
//					if(USART_RX_STA>(USART_REC_LEN-1))USART_RX_STA=0;//接收数据错误,重新开始接收	  
//				}		 
//			}
//		}  		 									     
//	} 
//#if SYSTEM_SUPPORT_OS 	//如果SYSTEM_SUPPORT_OS为真，则需要支持OS.
//	OSIntExit();  											 
//#endif





} 
#endif										 
//初始化IO 串口1
//pclk2:PCLK2时钟频率(Mhz)
//bound:波特率 
void uart_init(u32 pclk2,u32 bound)
{  	 
	float temp;
	u16 mantissa;
	u16 fraction;	   
	temp=(float)(pclk2*1000000)/(bound*16);//得到USARTDIV@OVER8=0
	mantissa=temp;				 //得到整数部分
	fraction=(temp-mantissa)*16; //得到小数部分@OVER8=0 
    mantissa<<=4;
	mantissa+=fraction; 
	RCC->AHB1ENR|=1<<0;   	//使能PORTA口时钟  
	RCC->APB2ENR|=1<<4;  	//使能串口1时钟 
	GPIO_Set(GPIOA,PIN9|PIN10,GPIO_MODE_AF,GPIO_OTYPE_PP,GPIO_SPEED_50M,GPIO_PUPD_PU);//PA9,PA10,复用功能,上拉输出
 	GPIO_AF_Set(GPIOA,9,7);	//PA9,AF7
	GPIO_AF_Set(GPIOA,10,7);//PA10,AF7  	   
	//波特率设置
 	USART1->BRR=mantissa; 	//波特率设置	 
	USART1->CR1&=~(1<<15); 	//设置OVER8=0 
	USART1->CR1|=1<<3;  	//串口发送使能 
#if EN_USART1_RX		  	//如果使能了接收
	//使能接收中断 
	USART1->CR1|=1<<2;  	//串口接收使能
	USART1->CR1|=1<<5;    	//接收缓冲区非空中断使能	    	
	MY_NVIC_Init(3,3,USART1_IRQn,2);//组2，最低优先级 
#endif
	USART1->CR1|=1<<13;  	//串口使能
}




//PG9--USART6_RX   PG14--USART6_TX


void K210_USART(u32 pclk2,u32 bound){
	
	 
	float temp;
	u16 mantissa;
	u16 fraction;	   
	temp=(float)(pclk2*1000000)/(bound*16);//得到USARTDIV@OVER8=0
	mantissa=temp;				 //得到整数部分
	fraction=(temp-mantissa)*16; //得到小数部分@OVER8=0 
    mantissa<<=4;
	mantissa+=fraction; 
	RCC->AHB1ENR|=1<<0;   	//使能PORTA口时钟  
	RCC->APB2ENR|=1<<4;  	//使能串口1时钟 
	GPIO_Set(GPIOA,PIN9|PIN10,GPIO_MODE_AF,GPIO_OTYPE_PP,GPIO_SPEED_50M,GPIO_PUPD_PU);//PA9,PA10,复用功能,上拉输出
 	GPIO_AF_Set(GPIOG,9,8);	//PG9,AF8
	GPIO_AF_Set(GPIOG,14,8);//PG14,AF8  	   
	//波特率设置
 	USART1->BRR=mantissa; 	//波特率设置	 
	USART1->CR1&=~(1<<15); 	//设置OVER8=0 
	USART1->CR1|=1<<3;  	//串口发送使能 
#if EN_USART1_RX		  	//如果使能了接收
	//使能接收中断 
	USART6->CR1|=1<<2;  	//串口接收使能
	USART6->CR1|=1<<5;    	//接收缓冲区非空中断使能	    	
	MY_NVIC_Init(3,2,USART6_IRQn,2);//组2，最低优先级 
#endif
	USART6->CR1|=1<<13;  	//串口使能
}


void USART6_IRQHandler(void)
{
//	u8 res;	
//	if(USART6->SR&(1<<5))//接收到数据
//	{	 
//		res=USART6->DR; 
//		if((USART6_RX_STA&0x8000)==0)//接收未完成
//		{
//			if(USART6_RX_STA&0x4000)//接收到了0x0d
//			{
//				if(res!=0x0a)USART6_RX_STA=0;//接收错误,重新开始
//				else USART6_RX_STA|=0x8000;	//接收完成了 
//			}else //还没收到0X0D
//			{	
//				if(res==0x0d)USART6_RX_STA|=0x4000;
//				else
//				{
//					USART6_RX_BUF[USART6_RX_STA&0X3FFF]=res;
//					USART6_RX_STA++;
//					if(USART6_RX_STA>(USART6_REC_LEN-1))USART6_RX_STA=0;//接收数据错误,重新开始接收	  
//				}		 
//			}
//		}  		 									     
//	} 
	u8 Data=0;
    if (USART_GetFlagStatus(USART6, USART_FLAG_PE) != RESET)
   {
       USART_ReceiveData(USART6);
     USART_ClearFlag(USART6, USART_FLAG_PE);
   }
   if (USART_GetFlagStatus(USART6, USART_FLAG_ORE) != RESET)
   {
       USART_ReceiveData(USART6);
     USART_ClearFlag(USART6, USART_FLAG_ORE);
   }
    
    if (USART_GetFlagStatus(USART6, USART_FLAG_FE) != RESET)
   {
       USART_ReceiveData(USART6);
      USART_ClearFlag(USART6, USART_FLAG_FE);
   }
//为了避免接收错误,将一些不正常状态滤掉
    if(USART_GetITStatus(USART6, USART_IT_RXNE) != RESET)
    {   
        USART_ClearFlag(USART6, USART_FLAG_RXNE);
        USART_ClearITPendingBit(USART6, USART_IT_RXNE);
        Data = USART_ReceiveData(USART6);
		OPENMV_date_anl(Data); //处理函数
    } 


} 




extern int boll_x;
extern int boll_y;
void OPENMV_date_anl(u8 data)
{
	static u8 RxBuffer[10];
	static u8 state = 0;
/*通信格式 0xAA 0x55 data1 data2 checkout 0x54*/	
/*其中checkout=(data1+data2)低八位  比如 data1=0xe1,data2=0xf3,data1+data2=0x1d4,则checkout=0xd4*/
	if(state==0&&data==0xAA)
		state=1;
	else if(state==1&&data==0x55)
		state=2;
	else if(state==2)
	{
		RxBuffer[0]=data;//x
			state=3;
	}
	else if(state==3)
	{	
		RxBuffer[1]=data;//y
		state = 4;
	}
	else if(state==4)
	{	
		RxBuffer[2]=data;//checkout
		state = 5;
	}

	else if(state==5&&data==0x54)
	{	
		if(RxBuffer[2]==(u8)(RxBuffer[0]+RxBuffer[1]))//校验成功
		{
		boll_x=RxBuffer[0];
		boll_y=RxBuffer[1];

		}
	
		state = 0;
	}
	else
		state = 0;
}








